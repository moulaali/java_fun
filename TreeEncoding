
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Stack;

/**
 * A demo class to encode a Tree in parenthesis based expression.
 * 
 * @author Moulaali Shaik
 */
public class TreeEncoding {
  
  private static class Node {
    private final int data;
    List<Node> children;
    
    Node(int data) {
      this.data = data;
      this.children = new ArrayList<>();
    }
    
    Node addChild(Node childNode) {
      children.add(childNode);
      return this;
    }
    
    Node addChildren(List<Node> children) {
      this.children.addAll(children);
      return this;
    }
    
    static Node newMarkerNode() {
      return new Node(Integer.MIN_VALUE);
    }
    
    boolean isMarkerNode() {
      return (data == Integer.MIN_VALUE);
    }
    
    @Override
    public String toString() {
      return String.valueOf(data);
    }

    String encode() {
      StringBuilder sb = new StringBuilder();
      encode(this, sb);
      return sb.toString();
    }
    
    void encode(Node node, StringBuilder sb) {
      sb.append("(");
      sb.append(node.data);
      for (Node child : node.children) {
        encode(child, sb);
      }
      sb.append(")");
    }
    
    static Node decode(String encoded) {
      Stack<Node> stack = new Stack<>();
      for (int i = 0; i < encoded.length(); i++) {
        char c = encoded.charAt(i);
        switch (c) {
          case '(':
            stack.push(newMarkerNode());
            break;
          case ')':
            LinkedList<Node> children = new LinkedList<>();
            while (!stack.isEmpty()) {
              Node node = stack.pop();
              if (stack.peek().isMarkerNode()) { // Parent Node sits before marker-node
                stack.pop(); // remove the marker node
                node.addChildren(children);
                stack.push(node); 
                break;
              } else {
                children.addFirst(node);
              }
            }
            break;
          default :
            stack.push(new Node(Character.getNumericValue(c)));
        }
      }
      return stack.pop();
    }

    String toLevelOrder() {
      StringBuilder outputBuilder = new StringBuilder();
      LinkedList<Node> queue = new LinkedList<>();

      // Eneque the root
      queue.add(this);
      queue.add(newMarkerNode());
      
      while (!queue.isEmpty()) {
        Node node = queue.removeFirst();
        
        // Handle level completion
        if (node.data == Integer.MIN_VALUE) {
          outputBuilder.append("\n");
          if (!queue.isEmpty()) {
            queue.add(newMarkerNode());
          }
          continue;
        }
        
        // Print this node and enequeue all the children
        boolean lastNodeInLevel = (queue.peek() != null) && (queue.peek().isMarkerNode());
        outputBuilder.append(node.toString() + (lastNodeInLevel ? "" : ", "));
        queue.addAll(node.children);
      }
      
      return outputBuilder.toString();
    }
  }
  
  public static void main(String[] args) {
    // Build a Tree manually
    Node root = new Node(1);
    
    Node level1Child1 = new Node(2);
    Node level1Child2 = new Node(3);
    Node level1Child3 = new Node(4);
    
    root
      .addChild(level1Child1)
      .addChild(level1Child2)
      .addChild(level1Child3);
    
    Node level2Child1 = new Node(5);
    Node level2Child2 = new Node(6);
    Node level2Child3 = new Node(7);

    level1Child1
      .addChild(level2Child1);
    level1Child2
      .addChild(level2Child2);
    level1Child3
      .addChild(level2Child3);
    
    
    // Level wise :
    // 1
    // 2, 3, 4
    // 5, 6, 7
    System.out.println("Level Order :\n" + root.toLevelOrder());
    
    // Encoding demo
    String encoded = root.encode();
    System.out.println("Encoded Tree : " + encoded);
    Node decoded = Node.decode(encoded);
    System.out.println("Decoded back to Level Order : \n" + decoded.toLevelOrder());
    System.out.println("Re-Encoded Tree : " + decoded.encode());
  }
}
